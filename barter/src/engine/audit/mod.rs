use crate::{
    engine::{
        audit::context::EngineContext,
        error::UnrecoverableEngineError,
        state::{instrument::market_data::MarketDataState, EngineState},
        EngineOutput,
    },
    EngineEvent,
};
use barter_integration::collection::one_or_many::OneOrMany;
use derive_more::Constructor;
use serde::{Deserialize, Serialize};
use shutdown::ShutdownAudit;

/// Defines data structures that represent the context an `Engine` [`AuditTick`] was generated.
pub mod context;

/// Defines an `Engine` shutdown audit.
pub mod shutdown;

/// Defines a `StateReplicaManager` that can be used to maintain an `EngineState` replica.
///
/// Useful for supporting non-hot path trading system components such as UIs, web apps, etc.
pub mod state_replica;

/// Convenient type alias for the default `Engine` `AuditTick`.
pub type DefaultAuditTick<
    MarketState: MarketDataState,
    StrategyState,
    RiskState,
    OnTradingDisabled,
    OnDisconnect,
> = AuditTick<
    DefaultAudit<MarketState, StrategyState, RiskState, OnTradingDisabled, OnDisconnect>,
    EngineContext,
>;

/// Convenient type alias for the default `Engine` `Audit`.
pub type DefaultAudit<
    MarketState: MarketDataState,
    StrategyState,
    RiskState,
    OnTradingDisabled,
    OnDisconnect,
> = Audit<
    EngineState<MarketState, StrategyState, RiskState>,
    EngineEvent<MarketState::EventKind>,
    EngineOutput<OnTradingDisabled, OnDisconnect>,
>;

/// Convenient type alias for a custom `Engine` `Audit` - generic over the `Event`.
///
/// Note that by default the `Engine` used the `EngineEvent` type.
pub type CustomAudit<
    Event,
    MarketState,
    StrategyState,
    RiskState,
    OnTradingDisabled,
    OnDisconnect,
> = Audit<
    EngineState<MarketState, StrategyState, RiskState>,
    Event,
    EngineOutput<OnTradingDisabled, OnDisconnect>,
>;

/// Interface that defines how a component (eg/ `Engine`) generates [`AuditTick`]s.
pub trait Auditor<AuditKind>
where
    AuditKind: From<Self::Snapshot>,
{
    /// `AuditTick` context.
    ///
    /// For example, the `Engine` uses [`EngineContext`].
    type Context;

    /// State snapshot audit.
    type Snapshot;

    /// Shutdown audit.
    type Shutdown<Event>;

    /// Returns a full system state snapshot - useful for generating a snapshot audit.
    fn snapshot(&self) -> Self::Snapshot;

    /// Builds an [`AuditTick`] using the provided `AuditKind`.
    fn audit<Kind>(&mut self, kind: Kind) -> AuditTick<AuditKind, Self::Context>
    where
        AuditKind: From<Kind>;
}

/// `Engine` audit event & it's associated context. Sent via the AuditStream.
///
/// For example, see the `Engine` [`DefaultAuditTick`].
#[derive(
    Debug,
    Copy,
    Clone,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    Hash,
    Default,
    Deserialize,
    Serialize,
    Constructor,
)]
pub struct AuditTick<Kind, Context> {
    pub event: Kind,
    pub context: Context,
}

/// Represents [`AuditTick`] types that are generated by the `Engine` and sent via the AuditStream.
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Deserialize, Serialize)]
pub enum Audit<State, Event, Output> {
    /// `EngineState` snapshot.
    Snapshot(State),
    /// `Engine` processed an `Event`, and produced no output.
    Process(Event),
    /// `Engine` processed an `Event`, and produced an output.
    ProcessWithOutput(Event, Output),
    /// `Engine` shutdown.
    Shutdown(ShutdownAudit<Event>),
    /// `Engine` shutdown, and also produced an output.
    ShutdownWithOutput(ShutdownAudit<Event>, Output),
}

impl<State, Event, Output> From<&Audit<State, Event, Output>> for Option<ShutdownAudit<Event>>
where
    Event: Clone,
{
    fn from(value: &Audit<State, Event, Output>) -> Self {
        match value {
            Audit::Shutdown(shutdown) => Some(shutdown.clone()),
            Audit::ShutdownWithOutput(shutdown, _) => Some(shutdown.clone()),
            _ => None,
        }
    }
}

impl<State, Event, Output> Audit<State, Event, Output> {
    pub fn snapshot<S>(state: S) -> Self
    where
        S: Into<State>,
    {
        Self::Snapshot(state.into())
    }

    pub fn process<E>(event: E) -> Self
    where
        E: Into<Event>,
    {
        Self::Process(event.into())
    }

    pub fn process_with_trading_disabled<E, Disabled>(event: E, disabled: Disabled) -> Self
    where
        E: Into<Event>,
        Disabled: Into<Output>,
    {
        Self::ProcessWithOutput(event.into(), disabled.into())
    }

    pub fn process_with_output<E, O>(event: E, output: O) -> Self
    where
        E: Into<Event>,
        O: Into<Output>,
    {
        Self::ProcessWithOutput(event.into(), output.into())
    }

    pub fn shutdown_commanded<E>(event: E) -> Self
    where
        E: Into<Event>,
    {
        Self::Shutdown(ShutdownAudit::Commanded(event.into()))
    }

    pub fn shutdown_on_err_with_output<E, O>(
        event: E,
        unrecoverable: OneOrMany<UnrecoverableEngineError>,
        output: O,
    ) -> Self
    where
        E: Into<Event>,
        O: Into<Output>,
    {
        Self::ShutdownWithOutput(
            ShutdownAudit::Error(event.into(), unrecoverable),
            output.into(),
        )
    }
}

impl<Market, Strategy, Risk, Event, Output> From<EngineState<Market, Strategy, Risk>>
    for Audit<EngineState<Market, Strategy, Risk>, Event, Output>
{
    fn from(value: EngineState<Market, Strategy, Risk>) -> Self {
        Self::Snapshot(value)
    }
}
